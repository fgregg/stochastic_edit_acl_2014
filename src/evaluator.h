// Licensed  under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: ryan.cotterell@gmail.com (Ryan Cotterell)
//

#include <string>
#include <set>
#include <cmath>
#include <cfloat>
#include <stdlib.h>
#include <stddef.h>
#include <map>
#include <vector>
#include <time.h>
#include <algorithm>
#include <sstream>

//OpenFST
#include <fst/fstlib.h>
#include <fst/fst-decl.h>
#include <fst/map.h>

//Boost
#include <boost/algorithm/string/split.hpp>
#include <boost/algorithm/string/classification.hpp>
#include <boost/ptr_container/ptr_vector.hpp>
#include <boost/lexical_cast.hpp>


//DLIB 
#include <dlib/optimization.h>


// for the string_to_fst functton. Should be in a util class?

using namespace fst;


/*
  Notes on design decisions. 

  1. Why is the case that I pass in an FST but return  string?
  
  A generic string to fst method is harder to write than a generic
  fst to string method. I think It will just be a pain to do, but it 
  should be possible. I will look into it later and update the code
  accordingly
  
 */



class Evaluator {

 private:
  VectorFst<LogArc> *fst;
  VectorFst<StdArc> fst_std;
  VectorFst<FeatureArc> *fst_feature;
  
  fsa_data test_data;
  int num_features;

  VectorFst<StdArc> edit_dist_std;
  VectorFst<LogArc> edit_dist_log;

  /*
    Should be in generic util library
   */
  string fst_to_string(VectorFst<StdArc> *fst) {


  string output = "";
  
  for (StateIterator<VectorFst<StdArc> > siter(*fst); !siter.Done(); siter.Next()) {
    int state_id = siter.Value();
    for (ArcIterator<VectorFst<StdArc> > aiter(*fst,state_id); !aiter.Done(); aiter.Next()) {
      
      const StdArc &cur_arc = aiter.Value();
      //prevent epsilons
      if (cur_arc.olabel != 0) {
	string label = fst->OutputSymbols()->Find(cur_arc.olabel);
	std::reverse(label.begin(),label.end());
	output = output + label;
      }
    }

  }

  return output;
  
}


 public:

  //computes the k -best with their associated probabilities (renormalized)
  vector<pair<string,double> > k_best_weighted(VectorFst<LogArc>, int k);
  //computes the simple k-best
  vector<string> k_best(VectorFst<LogArc> x, int k);

  //Viterbi decode with reference to original 
  //arcs to get the context it passes through
  pair<string,double> alignment_decode(VectorFst<LogArc> * x) {
    VectorFst<StdArc> x_std,final;
    VectorFst<FeatureArc> x_feature;
    WFST_Trainer_Local::map_to_feature_arcs(x,&x_feature,true);
    x_feature.SetInputSymbols(x->InputSymbols());
    x_feature.SetOutputSymbols(x->OutputSymbols());

    VectorFst<FeatureArc> medial;
    Compose<FeatureArc>(x_feature,*fst_feature,&medial);
    //converts to (max,*) semiring
    ArcMap(*x,&x_std,WeightConvertMapper<LogArc,StdArc>());
    Compose<StdArc>(x_std,fst_std,&final);

    //iterate over states and arcs and modify the 
    //strings on the arcs to be the unique arc id
    // in the original machine
    // we can then use this in our arc id to action
    // mapping generated by the python script
    // to get the exact sequence of actions that was taken

    //it is necessary to make a new symbol table with 
    // one entry for each of the 
    SymbolTable arc_idSymbolTable;
    arc_idSymbolTable.AddSymbol("<eps>",0);
    for (int i = 1; i <= num_features; ++i) {
      string key = boost::lexical_cast<string>(i - 1);
      arc_idSymbolTable.AddSymbol(key + " "  ,i);
    }
    final.SetInputSymbols(&arc_idSymbolTable);
    final.SetOutputSymbols(&arc_idSymbolTable);

    int arc_id = 0;
    for (StateIterator<VectorFst<FeatureArc> > siter(medial); !siter.Done(); siter.Next()) {
      int state_id = siter.Value();
      
      map<int,int> arc_mapper;
    
      int tmp = arc_id;
      
      int old_arc_id = 0;
      for (ArcIterator<VectorFst<FeatureArc> > aiter1(medial,state_id); !aiter1.Done(); aiter1.Next()) {
   	const FeatureArc &arc = aiter1.Value();
      	old_arc_id = round(exp(-arc.weight.Value2().Value()));
	arc_mapper[tmp] = old_arc_id;
	
	++tmp;
      }
      
      for (MutableArcIterator<VectorFst<StdArc> > aiter2(&final,state_id); !aiter2.Done(); aiter2.Next()) {
	const StdArc &cur_arc = aiter2.Value();
	string key = boost::lexical_cast<string>(arc_mapper[arc_id]);
	//cout << arc_idSymbolTable.Find(key) << "\n";
	int arc_label = arc_idSymbolTable.Find(key + " " );
	//cout << arc_label << "\n";
	const StdArc arc = StdArc(arc_label,arc_label,cur_arc.weight,cur_arc.nextstate);
	aiter2.SetValue(arc);
	++arc_id;
      }

    }

    VectorFst<StdArc> shortestPath;
    ShortestPath(final,&shortestPath,1);
   
    TropicalWeight w = ShortestDistance(final);
    
    string s = fst_to_string(&shortestPath);
    std::reverse(s.begin(),s.end());
    return pair<string,double>(s,w.Value());
  }

    //Viterbi decode with reference to original 
  //arcs to get the context it passes through
  pair<string,double> alignment_decode_forced(VectorFst<LogArc> * x, VectorFst<LogArc> * y) {
    VectorFst<StdArc> x_std,y_std,medial_std,final_std;
    VectorFst<FeatureArc> x_feature,y_feature;
    WFST_Trainer_Local::map_to_feature_arcs(x,&x_feature,true);
    WFST_Trainer_Local::map_to_feature_arcs(y,&y_feature,true);
    x_feature.SetInputSymbols(x->InputSymbols());
    x_feature.SetOutputSymbols(x->OutputSymbols());
    y_feature.SetInputSymbols(y->InputSymbols());
    y_feature.SetOutputSymbols(y->OutputSymbols());

    
    VectorFst<FeatureArc> medial_feature,final_feature;
    Compose<FeatureArc>(x_feature,*fst_feature,&medial_feature);
    Compose<FeatureArc>(medial_feature,y_feature,&final_feature);

    //converts to (max,*) semiring
    ArcMap(*x,&x_std,WeightConvertMapper<LogArc,StdArc>());
    ArcMap(*y,&y_std,WeightConvertMapper<LogArc,StdArc>());
    Compose<StdArc>(x_std,fst_std,&medial_std);
    Compose<StdArc>(medial_std,y_std,&final_std);
    
    //iterate over states and arcs and modify the 
    //strings on the arcs to be the unique arc id
    // in the original machine
    // we can then use this in our arc id to action
    // mapping generated by the python script
    // to get the exact sequence of actions that was taken

    //it is necessary to make a new symbol table with 
    // one entry for each of the 
    SymbolTable arc_idSymbolTable;
    arc_idSymbolTable.AddSymbol("<eps>",0);
    for (int i = 1; i <= num_features; ++i) {
      string key = boost::lexical_cast<string>(i - 1);
      arc_idSymbolTable.AddSymbol(key + " "  ,i);
    }
    final_std.SetInputSymbols(&arc_idSymbolTable);
    final_std.SetOutputSymbols(&arc_idSymbolTable);

    int arc_id = 0;
    for (StateIterator<VectorFst<FeatureArc> > siter(final_feature); !siter.Done(); siter.Next()) {
      int state_id = siter.Value();
      
      map<int,int> arc_mapper;
    
      int tmp = arc_id;
      
      int old_arc_id = 0;
      for (ArcIterator<VectorFst<FeatureArc> > aiter1(final_feature,state_id); !aiter1.Done(); aiter1.Next()) {
   	const FeatureArc &arc = aiter1.Value();
      	old_arc_id = round(exp(-arc.weight.Value2().Value()));
	arc_mapper[tmp] = old_arc_id;
	
	++tmp;
      }
      
      for (MutableArcIterator<VectorFst<StdArc> > aiter2(&final_std,state_id); !aiter2.Done(); aiter2.Next()) {
	const StdArc &cur_arc = aiter2.Value();
	string key = boost::lexical_cast<string>(arc_mapper[arc_id]);
	//cout << arc_idSymbolTable.Find(key) << "\n";
	int arc_label = arc_idSymbolTable.Find(key + " " );
	//cout << arc_label << "\n";
	const StdArc arc = StdArc(arc_label,arc_label,cur_arc.weight,cur_arc.nextstate);
	aiter2.SetValue(arc);
	++arc_id;
      }

    }

    VectorFst<StdArc> shortestPath;
    ShortestPath(final_std,&shortestPath,1);
    TropicalWeight w = ShortestDistance(final_std);
    
    string s = fst_to_string(&shortestPath);
    std::reverse(s.begin(),s.end());
    return pair<string,double>(s,w.Value());
  }
  
  //compues the one best
  string one_best(VectorFst<LogArc> *x) {
    VectorFst<StdArc> x_std,final;
    
    
    //fst_std.Write("one_best_fst.fst");
    ArcMap(*x,&x_std,WeightConvertMapper<LogArc,StdArc>());
    
    //x_std.Write("whatever1.fst");
    Compose<StdArc>(x_std,fst_std,&final);
    VectorFst<StdArc> shortestPath;
    ShortestPath(final,&shortestPath,1);
    //shortestPath.Write("whatever2.fst");
    string s = fst_to_string(&shortestPath);
    std::reverse(s.begin(),s.end());
    return s;
  }


  /*
   * Takes the training data loaded in the
   * the constructur and computes the
   * edit distance from the gold example
   * to the one best
   *
   */ 
  double one_best_edit() {
    double edit_dist = 0.0;
    for (fsa_data::iterator it = this->test_data.begin(); it != this->test_data.end(); ++it) {
       datum_formatted exemplar = *it;
       StdVectorFst input_fst_std, output_fst_std; 
       VectorFst<LogArc> input_fst = exemplar.first;
       VectorFst<LogArc> output_fst = exemplar.second;
       ArcMap(input_fst,&input_fst_std,WeightConvertMapper<LogArc,StdArc>());
       ArcMap(output_fst,&output_fst_std,WeightConvertMapper<LogArc,StdArc>());
       VectorFst<StdArc> x_std,final;
       Compose<StdArc>(input_fst_std,fst_std,&final);
       VectorFst<StdArc> shortestPath;
       ShortestPath(final,&shortestPath,1);
       VectorFst<StdArc> shortestPath_reversed;
       Project(&shortestPath, ProjectType(2));
       Reverse(shortestPath,&shortestPath_reversed);
       Map(&shortestPath_reversed, RmWeightMapper<StdArc>());
       //RmEpsilon(&shortestPath_reversed);
       VectorFst<StdArc> medial_edit,final_edit; 
       Compose<StdArc>(output_fst_std, edit_dist_std,&medial_edit);
       Compose<StdArc>(medial_edit,shortestPath_reversed,&final_edit);
       TropicalWeight w = ShortestDistance(final_edit);
       edit_dist += w.Value();
    }
    return edit_dist;
  }

  /*
   * Takes the training data loaded in the
   * the constructur and computes the
   * edit distance from the gold example
   * to the one best
   *
   */ 
  double expected_edit_distance() {
    double edit_dist = 0.0;
    int i = 0;
    for (fsa_data::iterator it = this->test_data.begin(); it != this->test_data.end(); ++it) {
       datum_formatted exemplar = *it;
       
       VectorFst<LogArc> input_fst = exemplar.first;
       VectorFst<LogArc> output_fst = exemplar.second;
       VectorFst<LogArc> medial,final,pre_final_edit,final_edit;
       Compose<LogArc>(input_fst,*fst,&medial);
       Compose<LogArc>(medial,output_fst,&final);
       Project(&final, ProjectType(2));
       ArcSort(&final,ILabelCompare<LogArc>());
       Compose<LogArc>(final,edit_dist_log,&pre_final_edit);
       Compose<LogArc>(pre_final_edit,output_fst, &final_edit);
       //final.Write("final_before_edit.fst");
       //final_edit.Write("final_edit.fst");
       LogWeight w = ShortestDistance(final_edit);
       edit_dist += w.Value();
     }

    return edit_dist;
  }

  
  /*


   */
  double log_loss() {
    double log_loss = 0.0;
    for (fsa_data::iterator it = this->test_data.begin(); it != this->test_data.end(); ++it) {
      datum_formatted exemplar = *it;
      VectorFst<LogArc> input_fst = exemplar.first;
      VectorFst<LogArc> output_fst = exemplar.second;
      VectorFst<LogArc> medial,final;
      Compose<LogArc>(input_fst,*fst,&medial);
      Compose<LogArc>(medial,output_fst,&final);
      LogWeight w = ShortestDistance(final);
      log_loss += w.Value();
      
     }

    return log_loss;
  
  }

  /*
   *
   *
   */
  ~Evaluator() {
    delete this->fst_feature;
  }

  /*
   *
   * @param fst
   * @param num_features
   */
  Evaluator(VectorFst<LogArc> *fst, int num_features,
	    fsa_data test_data) {
    this->fst = fst;
    this->num_features = num_features;
    this->test_data = test_data;
 
    ArcMap(*fst,&fst_std,WeightConvertMapper<LogArc,StdArc>());

    this->fst_feature = new VectorFst<FeatureArc>();

    const  SymbolTable *isymbols = fst->InputSymbols();
    const SymbolTable *osymbols = fst->OutputSymbols();

    fst_feature->SetInputSymbols(isymbols);
    fst_feature->SetOutputSymbols(osymbols);
    WFST_Trainer_Local::map_to_feature_arcs(fst,fst_feature,false);
    fst_feature->SetInputSymbols(isymbols);
    fst_feature->SetOutputSymbols(osymbols);
   

    //creates teh edit distance machines
    //create the edit distance machines
    
    //add the appropriate symbol tables
    edit_dist_log.SetInputSymbols(osymbols);
    edit_dist_log.SetOutputSymbols(osymbols);
    edit_dist_std.SetInputSymbols(osymbols);
    edit_dist_std.SetOutputSymbols(osymbols);

    edit_dist_log.AddState();
    edit_dist_std.AddState();
    edit_dist_log.SetStart(0);
    edit_dist_std.SetStart(0);

    edit_dist_log.SetFinal(0,0);
    edit_dist_std.SetFinal(0,0);

    for (fst::SymbolTableIterator iit(*isymbols); !iit.Done(); iit.Next()) {
      const bool in_is_eps = iit.Value() == 0;
      if (!in_is_eps) {
	//deletion
	edit_dist_log.AddArc(0,LogArc(iit.Value(),0,1,0));
	edit_dist_std.AddArc(0,StdArc(iit.Value(),0,1,0));
      }
    }

    for (fst::SymbolTableIterator oit(*osymbols); !oit.Done(); oit.Next()) {
      const bool out_is_eps = oit.Value() == 0;
      if (!out_is_eps) {
	//insertion
	edit_dist_log.AddArc(0,LogArc(0,oit.Value(),1,0));
	edit_dist_std.AddArc(0,StdArc(0,oit.Value(),1,0));
      }
    }

    for (fst::SymbolTableIterator iit(*isymbols); !iit.Done(); iit.Next()) {
      const bool in_is_eps = iit.Value() == 0;
      for (fst::SymbolTableIterator oit(*osymbols); !oit.Done(); oit.Next()) {
	const bool out_is_eps = oit.Value() == 0;
	if (!in_is_eps && !out_is_eps) {
	  if (iit.Value() == oit.Value()) {
	    edit_dist_log.AddArc(0,LogArc(iit.Value(),oit.Value(),0,0));
	    edit_dist_std.AddArc(0,StdArc(iit.Value(),oit.Value(),0,0));
	  } else {
	    edit_dist_log.AddArc(0,LogArc(iit.Value(),oit.Value(),1,0));
	    edit_dist_std.AddArc(0,StdArc(iit.Value(),oit.Value(),1,0));
	  }
	}
      }
    }
  }
  
  
};



